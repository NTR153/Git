package dataStructures.hashTable;

/**
 * HastTable
 */
public class HashTable {
    // Hash Table is used to add key value pair to an address.
    // It is both "one way" (can get address using key but cannot get key using address) and "deterministic" (always get same address)

    // Collision - A collision occurs when more than one value to be hashed by a particular hash function 
    // hash to the same slot in the table or data structure (hash table) being generated by the hash function.

    // Collision can be handled by -
    // 1. Adding the key value pair to same address, also known as "Separate Chaining". eg. Linked List
    // 2. Adding the key value pair to the next open address (non consumed one), also known as "Linear Probing" or "Open Addressing" 

    private int size = 7;
    private Node[] dataMap;

    class Node {
        String key;
        int value;
        Node next;

        Node (String key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    public HashTable () {
        dataMap = new Node[size];
    }

    public void printTable() {
        for (int i=0; i<size; i++) {
            System.out.println(i + " : ");
            Node tempNode = dataMap[i];
            while (tempNode != null) {
                System.out.println(" { " + tempNode.key + " = " + tempNode.value + " } ");
                tempNode = tempNode.next;
            }
        }
    }

    private int hash(String key) {
        int hash = 0;
        char[] keyChars = key.toCharArray();
        for (int i=0; i<keyChars.length; i++) {
            int asciiValue = keyChars[i];
            hash = (hash+asciiValue*23) % dataMap.length;
        }
        return hash;
    }

    public void set(String key, int value) {
        int index = hash(key);
        Node newNode = new Node(key, value);
        if (dataMap[index]==null) {
            dataMap[index]=newNode;
        }
        else {
            Node tempNode = dataMap[index];
            while (tempNode.next!=null) {
                tempNode=tempNode.next;
            }
            tempNode.next=newNode;
        }
    }
}